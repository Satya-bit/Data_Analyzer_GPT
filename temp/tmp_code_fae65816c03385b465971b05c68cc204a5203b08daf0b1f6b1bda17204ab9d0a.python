# Python code to list columns and plot Male vs Female distribution

import os
import sys

# Step 1: Import required libraries
try:
    import pandas as pd
    import matplotlib.pyplot as plt
    import numpy as np
except ImportError as e:
    missing = str(e).split("'")[1] if "'" in str(e) else "a required library"
    print(f"Error: Missing library {missing}. Please install required packages (e.g., pandas, matplotlib) and re-run.")
    sys.exit(1)

# Step 2: Load the dataset
csv_path = "data.csv"
if not os.path.exists(csv_path):
    print("Error: data.csv not found in the working directory.")
    sys.exit(1)

# Try multiple encodings for robustness
read_errors = []
df = None
for enc in ["utf-8", "utf-8-sig", "latin-1"]:
    try:
        df = pd.read_csv(csv_path, encoding=enc)
        break
    except Exception as e:
        read_errors.append((enc, str(e)))
if df is None:
    print("Error: Could not read data.csv. Tried encodings: " + ", ".join([e[0] for e in read_errors]))
    sys.exit(1)

# Step 3: List columns
columns = df.columns.tolist()

# Step 4: Detect gender column
def find_gender_column(dataframe):
    cols = dataframe.columns
    # Prioritize columns by name hints
    name_candidates = []
    for c in cols:
        lc = c.strip().lower()
        if any(key in lc for key in ["gender", "sex", "sexo", "sexe", "geschlecht", "genere"]):
            name_candidates.append(c)

    # Token mapping for gender detection
    token_to_std = {
        "m": "Male", "male": "Male", "man": "Male", "boy": "Male",
        "masculino": "Male", "macho": "Male", "homme": "Male",
        "hombre": "Male", "maschio": "Male", "masc": "Male",
        "f": "Female", "female": "Female", "woman": "Female", "girl": "Female",
        "femenino": "Female", "hembra": "Female", "femme": "Female",
        "mujer": "Female", "femmina": "Female", "fem": "Female",
        "männlich": "Male", "weiblich": "Female",
    }

    def score_column(col):
        s = dataframe[col]
        # Object-like: try to map tokens
        if s.dtype == object or pd.api.types.is_string_dtype(s):
            vals = s.dropna().astype(str).str.strip().str.lower()
            mapped = vals.map(token_to_std).dropna()
            return len(mapped), len(vals)
        # Numeric detection only for name-based candidates
        if pd.api.types.is_numeric_dtype(s):
            vals = s.dropna().astype(float)
            unique_vals = set(np.unique(vals))
            if unique_vals.issubset({0.0, 1.0}) or unique_vals.issubset({1.0, 2.0}):
                # Heuristic score: count of valid entries
                return len(vals), len(vals)
        return 0, max(1, len(s.dropna()))

    # 1) Evaluate name-based candidates first
    best_col = None
    best_ratio = 0
    best_mapped_count = 0
    for c in name_candidates:
        mapped, total = score_column(c)
        ratio = mapped / total if total > 0 else 0
        if ratio > best_ratio or (ratio == best_ratio and mapped > best_mapped_count):
            best_col, best_ratio, best_mapped_count = c, ratio, mapped

    # 2) If none by name, scan all columns and pick one with high ratio
    if best_col is None:
        for c in cols:
            mapped, total = score_column(c)
            ratio = mapped / total if total > 0 else 0
            if ratio > best_ratio or (ratio == best_ratio and mapped > best_mapped_count):
                best_col, best_ratio, best_mapped_count = c, ratio, mapped

        # Require a minimum confidence
        if best_ratio < 0.5 or best_mapped_count < 5:
            return None

    return best_col

gender_col = find_gender_column(df)

# Step 5: Compute Male/Female counts
male_count = 0
female_count = 0
others_count = 0
details_note = ""
if gender_col is not None:
    s = df[gender_col]
    # Standardize
    token_to_std = {
        "m": "Male", "male": "Male", "man": "Male", "boy": "Male",
        "masculino": "Male", "macho": "Male", "homme": "Male",
        "hombre": "Male", "maschio": "Male", "masc": "Male",
        "f": "Female", "female": "Female", "woman": "Female", "girl": "Female",
        "femenino": "Female", "hembra": "Female", "femme": "Female",
        "mujer": "Female", "femmina": "Female", "fem": "Female",
        "männlich": "Male", "weiblich": "Female",
    }

    standardized = None
    if s.dtype == object or pd.api.types.is_string_dtype(s):
        vals = s.astype(str).str.strip().str.lower()
        standardized = vals.map(token_to_std)
        # Count others that aren't directly Male/Female strings
        others_count = vals[~vals.isin(token_to_std.keys())].notna().sum()
    elif pd.api.types.is_numeric_dtype(s):
        # Heuristic mapping for numeric-coded gender (assumption)
        vals = s.astype(float)
        unique_vals = set(np.unique(vals.dropna()))
        if unique_vals.issubset({0.0, 1.0}):
            # Assume 1 = Male, 0 = Female
            standardized = vals.map(lambda x: "Male" if x == 1 else ("Female" if x == 0 else None))
            details_note = "Assumed numeric coding 1=Male, 0=Female for gender."
        elif unique_vals.issubset({1.0, 2.0}):
            # Assume 1 = Male, 2 = Female
            standardized = vals.map(lambda x: "Male" if x == 1 else ("Female" if x == 2 else None))
            details_note = "Assumed numeric coding 1=Male, 2=Female for gender."
        else:
            standardized = pd.Series([None]*len(vals))
    else:
        standardized = pd.Series([None]*len(s))

    male_count = (standardized == "Male").sum()
    female_count = (standardized == "Female").sum()
    # Recompute others_count more precisely for standardized series
    others_count = len(s) - (standardized.isin(["Male", "Female"]).sum()) - s.isna().sum()
else:
    details_note = "No likely gender column found; generated a placeholder plot."

# Step 6: Plot and save as output.png
plt.figure(figsize=(6, 4))
if gender_col is not None and (male_count + female_count) > 0:
    labels = ["Male", "Female"]
    counts = [int(male_count), int(female_count)]
    bars = plt.bar(labels, counts, color=["#4C78A8", "#F58518"])
    plt.title("Gender distribution (Male vs Female)")
    plt.ylabel("Count")
    for bar, val in zip(bars, counts):
        plt.text(bar.get_x() + bar.get_width()/2, bar.get_height() + max(1, 0.01*max(counts)), str(val),
                 ha='center', va='bottom', fontsize=9)
else:
    plt.bar(["No gender data"], [0], color="#BBBBBB")
    plt.title("Gender distribution unavailable")
    plt.ylabel("Count")
    plt.text(0, 0, "No gender column/data detected", ha='center', va='bottom', fontsize=9)

plt.tight_layout()
out_path = "output.png"
plt.savefig(out_path, dpi=150)
plt.close()

# Step 7: Print results
print("Columns in the dataset:")
print(", ".join(columns))
print("")
if gender_col is not None:
    print(f"Detected gender column: {gender_col}")
    print(f"Male count: {int(male_count)}")
    print(f"Female count: {int(female_count)}")
    if others_count > 0:
        print(f"Other/unmapped gender entries (excluded from plot): {int(others_count)}")
else:
    print("No likely gender column detected. A placeholder plot was saved.")

if details_note:
    print(f"Note: {details_note}")

print(f"Bar chart saved to {out_path}")
print("Task completed: Listed columns and generated gender distribution bar chart (Male vs Female) as output.png.")
